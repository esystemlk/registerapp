import{K as d,A as i,L as v,k as R,l as c,n as N,y as f,z as b,M as w,N as T,D as u,O as h,P as x,m as n,Q as U,o as C,p as q,q as P,v as K,T as S,F as e,U as _}from"./index-29trkLDX.js";const G=async()=>{if(!e)return v;const a=await d(i(n,"lecturers"));if(a.empty){for(const s of v)await R(c(i(n,"lecturers"),s.id),s);return(await d(i(n,"lecturers"))).docs.map(s=>({id:s.id,...s.data()}))}return a.docs.map(t=>({id:t.id,...t.data()}))},$=async a=>{if(!e)return v.find(o=>o.id===a)||null;const t=await N(c(n,"lecturers",a));return t.exists()?{id:t.id,...t.data()}:null},M=async a=>{if(!e)return v.find(p=>p.userId===a)||null;const t=f(i(n,"lecturers"),w("userId","==",a),h(1)),s=await d(t);if(s.empty)return null;const o=s.docs[0];return{id:o.id,...o.data()}},j=async(a,t)=>{e&&await S(c(n,"lecturers",a),{calendarIcsUrl:t})},z=async(a,t)=>{e&&await S(c(n,"lecturers",a),{weeklyTemplate:t})},H=async(a,t=7)=>{if(!e)return;await x(_,"publishAvailability")({lecturerId:a,days:t})},Q=async a=>{if(!e)return T.filter(r=>r.lecturerId===a);const t=i(n,"availability"),s=f(t,w("lecturerId","==",a),b("date","asc")),o=await d(s);if(o.empty){const r=T.filter(l=>l.lecturerId===a);for(const l of r)await u(t,l);return(await d(f(t,w("lecturerId","==",a),b("date","asc")))).docs.map(l=>({id:l.id,...l.data()}))}return o.docs.map(r=>({id:r.id,...r.data()}))},W=async(a,t,s)=>{if(!e)return;const o=c(n,"availability",a);await U(n,async r=>{const p=await r.get(o);if(!p.exists())throw new Error("Availability not found");const l=p.data(),g=(l.timeSlots||[]).findIndex(y=>y.id===t&&y.available);if(g===-1)throw new Error("Slot unavailable");l.timeSlots[g].available=!1,r.update(o,{timeSlots:l.timeSlots});const k=c(i(n,"bookings"));r.set(k,{...s,availabilityId:a,slotId:t,createdAt:new Date().toISOString()})})},Y=async(a,t)=>{if(!e)return"";const s=C(q,`receipts/${a}/${Date.now()}-${t.name}`);return await P(s,t),await K(s)},J=async a=>{if(!e)return[];const t=f(i(n,"bookings"),w("studentId","==",a),b("date","asc"));return(await d(t)).docs.map(o=>({id:o.id,...o.data()}))},V=async()=>{if(!e)return[];const a=f(i(n,"bookings"),w("paymentStatus","==","PENDING"));return(await d(a)).docs.map(s=>({id:s.id,...s.data()}))},X=async(a,t)=>{if(!e)return;const s=c(n,"bookings",a);await S(s,t);try{await u(i(s,"activity"),{type:"STATUS_UPDATE",patch:t,at:new Date().toISOString()}),await u(i(n,"notificationEvents"),{type:"BOOKING_UPDATED",bookingId:a,at:new Date().toISOString(),patch:t}),await u(i(n,"emailOutbox"),{type:"BOOKING_UPDATED",bookingId:a,at:new Date().toISOString(),patch:t})}catch{}},Z=async a=>{if(!e)return[];const t=f(i(n,"bookings"),w("lecturerId","==",a),b("date","asc"));return(await d(t)).docs.map(o=>({id:o.id,...o.data()}))},tt=async()=>e?(await d(i(n,"users"))).docs.map(t=>({id:t.id,...t.data()})):[],at=async(a,t)=>{e&&await S(c(n,"users",a),{role:t})},st=async()=>e?(await d(i(n,"bookings"))).docs.map(t=>({id:t.id,...t.data()})):[],nt=async(a,t,s,o,r,p,l)=>{if(!e)return;const g=c(n,"availability",o),k=c(n,"bookings",a);await U(n,async y=>{const A=await y.get(g);if(!A.exists())throw new Error("New availability not found");const D=A.data(),O=(D.timeSlots||[]).findIndex(m=>m.id===r&&m.available);if(O===-1)throw new Error("New slot unavailable");if(D.timeSlots[O].available=!1,y.update(g,{timeSlots:D.timeSlots}),t&&s){const m=c(n,"availability",t),E=await y.get(m);if(E.exists()){const I=E.data(),B=(I.timeSlots||[]).findIndex(L=>L.id===s);B!==-1&&(I.timeSlots[B].available=!0,y.update(m,{timeSlots:I.timeSlots}))}}y.update(k,{date:p,time:l,availabilityId:o,slotId:r,status:"CONFIRMED"})});try{await u(i(k,"activity"),{type:"RESCHEDULE",newDate:p,newTime:l,at:new Date().toISOString()})}catch{}},et=async a=>{if(!e)return null;const t=await N(c(n,"bookings",a));return t.exists()?{id:t.id,...t.data()}:null},it=async a=>e?(await d(f(i(n,"bookings",a,"activity"),b("at","asc")))).docs.map(s=>({id:s.id,...s.data()})):[],ot=async()=>e?(await d(i(n,"users"))).docs.map(t=>({id:t.id,...t.data()})).filter(t=>!!t.kycStatus):[],rt=async(a,t,s)=>{if(e){await S(c(n,"users",a),{kycStatus:t});try{await u(i(n,"users",a,"kycAudit"),{status:t,reason:s||null,at:new Date().toISOString()}),await u(i(n,"emailOutbox"),{type:"KYC_"+t,toUserId:a,at:new Date().toISOString(),reason:s||null})}catch{}}},ct=async(a,t,s)=>{e&&await u(i(n,"support"),{userId:a,subject:t,message:s,status:"OPEN",tags:[],assignedTo:null,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()})},lt=async()=>e?(await d(i(n,"support"))).docs.map(t=>({id:t.id,...t.data()})):[],dt=async(a,t)=>{e&&await S(c(n,"support",a),{...t,updatedAt:new Date().toISOString()})},ut=async(a,t="Test notification",s="Push delivery test")=>{e&&await u(i(n,"notificationEvents"),{type:"TEST_NOTIFICATION",toUserId:a,title:t,body:s,at:new Date().toISOString()})};export{Q as a,J as b,nt as c,Z as d,M as e,z as f,$ as g,V as h,tt as i,st as j,X as k,G as l,at as m,ut as n,et as o,H as p,it as q,W as r,j as s,ot as t,Y as u,rt as v,lt as w,dt as x,ct as y};
