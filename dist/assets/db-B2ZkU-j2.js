import{E as d,y as i,G as v,h as x,i as c,l as R,w as f,x as b,H as w,I as L,A as y,J as N,K as T,k as n,L as U,m as C,n as q,o as K,p as P,M as g,F as e,N as _}from"./index-BpwiqXsp.js";const F=async()=>{if(!e)return v;const a=await d(i(n,"lecturers"));if(a.empty){for(const s of v)await x(c(i(n,"lecturers"),s.id),s);return(await d(i(n,"lecturers"))).docs.map(s=>({id:s.id,...s.data()}))}return a.docs.map(t=>({id:t.id,...t.data()}))},$=async a=>{if(!e)return v.find(o=>o.id===a)||null;const t=await R(c(n,"lecturers",a));return t.exists()?{id:t.id,...t.data()}:null},H=async a=>{if(!e)return v.find(u=>u.userId===a)||null;const t=f(i(n,"lecturers"),w("userId","==",a),N(1)),s=await d(t);if(s.empty)return null;const o=s.docs[0];return{id:o.id,...o.data()}},M=async(a,t)=>{e&&await g(c(n,"lecturers",a),{calendarIcsUrl:t})},j=async(a,t)=>{e&&await g(c(n,"lecturers",a),{weeklyTemplate:t})},J=async(a,t=7)=>{if(!e)return;await T(_,"publishAvailability")({lecturerId:a,days:t})},W=async a=>{if(!e)return L.filter(r=>r.lecturerId===a);const t=i(n,"availability"),s=f(t,w("lecturerId","==",a),b("date","asc")),o=await d(s);if(o.empty){const r=L.filter(l=>l.lecturerId===a);for(const l of r)await y(t,l);return(await d(f(t,w("lecturerId","==",a),b("date","asc")))).docs.map(l=>({id:l.id,...l.data()}))}return o.docs.map(r=>({id:r.id,...r.data()}))},Y=async(a,t,s)=>{if(!e)return;const o=c(n,"availability",a);await U(n,async r=>{const u=await r.get(o);if(!u.exists())throw new Error("Availability not found");const l=u.data(),S=(l.timeSlots||[]).findIndex(p=>p.id===t&&p.available);if(S===-1)throw new Error("Slot unavailable");l.timeSlots[S].available=!1,r.update(o,{timeSlots:l.timeSlots});const k=c(i(n,"bookings"));r.set(k,{...s,availabilityId:a,slotId:t,createdAt:new Date().toISOString()})})},z=async(a,t)=>{if(!e)return"";const s=C(q,`receipts/${a}/${Date.now()}-${t.name}`);return await K(s,t),await P(s)},Q=async a=>{if(!e)return[];const t=f(i(n,"bookings"),w("studentId","==",a),b("date","asc"));return(await d(t)).docs.map(o=>({id:o.id,...o.data()}))},V=async()=>{if(!e)return[];const a=f(i(n,"bookings"),w("paymentStatus","==","PENDING"));return(await d(a)).docs.map(s=>({id:s.id,...s.data()}))},X=async(a,t)=>{if(!e)return;const s=c(n,"bookings",a);await g(s,t);try{await y(i(s,"activity"),{type:"STATUS_UPDATE",patch:t,at:new Date().toISOString()}),await y(i(n,"notificationEvents"),{type:"BOOKING_UPDATED",bookingId:a,at:new Date().toISOString(),patch:t}),await y(i(n,"emailOutbox"),{type:"BOOKING_UPDATED",bookingId:a,at:new Date().toISOString(),patch:t})}catch{}},Z=async a=>{if(!e)return[];const t=f(i(n,"bookings"),w("lecturerId","==",a),b("date","asc"));return(await d(t)).docs.map(o=>({id:o.id,...o.data()}))},tt=async()=>e?(await d(i(n,"users"))).docs.map(t=>({id:t.id,...t.data()})):[],at=async(a,t)=>{e&&await g(c(n,"users",a),{role:t})},st=async()=>e?(await d(i(n,"bookings"))).docs.map(t=>({id:t.id,...t.data()})):[],nt=async(a,t,s,o,r,u,l)=>{if(!e)return;const S=c(n,"availability",o),k=c(n,"bookings",a);await U(n,async p=>{const I=await p.get(S);if(!I.exists())throw new Error("New availability not found");const D=I.data(),B=(D.timeSlots||[]).findIndex(m=>m.id===r&&m.available);if(B===-1)throw new Error("New slot unavailable");if(D.timeSlots[B].available=!1,p.update(S,{timeSlots:D.timeSlots}),t&&s){const m=c(n,"availability",t),E=await p.get(m);if(E.exists()){const A=E.data(),O=(A.timeSlots||[]).findIndex(h=>h.id===s);O!==-1&&(A.timeSlots[O].available=!0,p.update(m,{timeSlots:A.timeSlots}))}}p.update(k,{date:u,time:l,availabilityId:o,slotId:r,status:"CONFIRMED"})});try{await y(i(k,"activity"),{type:"RESCHEDULE",newDate:u,newTime:l,at:new Date().toISOString()})}catch{}},et=async a=>{if(!e)return null;const t=await R(c(n,"bookings",a));return t.exists()?{id:t.id,...t.data()}:null},it=async a=>e?(await d(f(i(n,"bookings",a,"activity"),b("at","asc")))).docs.map(s=>({id:s.id,...s.data()})):[],ot=async()=>e?(await d(i(n,"users"))).docs.map(t=>({id:t.id,...t.data()})).filter(t=>!!t.kycStatus):[],rt=async(a,t,s)=>{if(e){await g(c(n,"users",a),{kycStatus:t});try{await y(i(n,"users",a,"kycAudit"),{status:t,reason:s||null,at:new Date().toISOString()}),await y(i(n,"emailOutbox"),{type:"KYC_"+t,toUserId:a,at:new Date().toISOString(),reason:s||null})}catch{}}},ct=async(a,t,s)=>{e&&await y(i(n,"support"),{userId:a,subject:t,message:s,status:"OPEN",tags:[],assignedTo:null,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()})},lt=async()=>e?(await d(i(n,"support"))).docs.map(t=>({id:t.id,...t.data()})):[],dt=async(a,t)=>{e&&await g(c(n,"support",a),{...t,updatedAt:new Date().toISOString()})};export{W as a,Q as b,nt as c,Z as d,H as e,j as f,$ as g,V as h,tt as i,st as j,X as k,F as l,at as m,et as n,it as o,J as p,ot as q,Y as r,M as s,rt as t,z as u,lt as v,dt as w,ct as x};
